#include <iostream>
#include <cmath>

int main()
{
	/// Task 4

	// Когато нямаме избор и трябва да правим сравнения между числа с плаващи запетаи, също така трябва да деклалираме една константа (в този случай EPSILON).
	// Изполваме я като "граница на грешка", тоест когато сравняваме две числа с плаващи запетаи и те са с някакви малки стойности по-големи или по-малки от колкото трябва да са, с епсилон се предпазавме от тези грешки.
	// Пример: float x = 2, y = 2; биха били равни ако стойностите им са на растояние EPSILON една от друга. В код:
	// fabs(x - y) <= EPSILON;
	const double EPSILON = 0.000000005;
	const double CIRCLE_RADIUS = 1;

	double x = 0;
	double y = 0;
	std::cout << "Please input x and y coordinates: ";
	std::cin >> x >> y;

	// В тази задача ползваме sqrt и fabs, които са функции, какво се функции ще изясним малко по-късно, 
	// но е важно да знаете че се намират в header file cmath и както на всяка програма, която ползва cout, се нуждае от iostream и вие пишете #include <iostream>, за математически функции ви трябва #include <cmath>
	// тук с малко геометрия се смята растоянието на точката от началото на координатната система(0,0), което също съвпада с центъра на кръга
	double distanceFromCenter = sqrt(x * x + y * y);


	// Епсилон се добавя в дясната страна, защото е възможно от изчислителни грешки да е малко по-голямо от радиуса, но все пак да се счита в кръга.
	// Ако растоянието на една точка от центъра на кръг <= от радиуса му, то тя лежи в кръга
	bool pointIsInCircle = distanceFromCenter <= CIRCLE_RADIUS + EPSILON;

	// Тук пък проверяваме дали точката се намира в окържност, а не в кръг (ползваме същия радиус, това е втората подточка на задачата).
	// Ако разликата (в абсолютни стойности чрез fabs) на distance и radius, е по-малка от епсилон (нашата "граница на грешка"), то ние ги считаме за равни.
	// Това всъщност е грешното решение, до което стигнахме по време на упражнението. То решава задачата ако става въпрос за окръжност, а горната проверка я решава ако става въпрос за кръг.
	bool pointIsOnEdgeOfCircle = fabs(distanceFromCenter - CIRCLE_RADIUS) <= EPSILON;

	std::cout << (pointIsInCircle ? "The point lies on the circle" : "The point lies outside the circle") << std::endl;
	std::cout << (pointIsOnEdgeOfCircle ? "The point lies on the edge of the circle" : "The point doesn't lie on the edge of the circle") << std::endl;

	// Също, да добавя един пропуск от упражнинието, там за абсолютни стойности ползвахме abs, което може да върне стойност от целочислен тип или от тип число с плаваща запетая.
	// Решава се какво да върне от компиратора чрез контескта.
	// Не е хубаво да се надяваме, че компилаторът ще улови правилния контекст, така че ползваме fabs, което винаги връща стойност от тип число с плаваща запетая.
}