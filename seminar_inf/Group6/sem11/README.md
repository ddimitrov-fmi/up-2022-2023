## <center> **Семинар по "Увод в програмирането"** </center>

## <center>**Рекурсия**</center>

## **1. Дефиниция на рекурсия**

Рекурсията в програмирането е функция, която извиква сама себе си. Рекурсивната дефиниция на една функция съдържа два етапа. Единият се нарича „основен случай“ или base case, в който достигайки до него рекурсията терминира. Трябва да има поне един базов случай, иначе програмата ни би работила до безкрай. Другият е „общ случай“, в който функцията извиква сама себе си и резултата се получава, чрез опростяване при всяко повикване.

Пример за рекурсива функция:

```cpp
int fact(int n)
{
    if (n <= 1) // base case
    {
        return 1;
    }

    //general case
    return n * factorial(n - 1);
}
```

Друг по-съкратен вариант на функцияата е:

```cpp
int fact(int n)
{
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```

Схема на различните етапи от рекурсията на функцията factorial при вход 5:

![recursion](images\recursionSchema.png)

Както се вижда на картинката имаме фаза на **разгъване на рекурсията(1-5) и фаза на сгъване(5-9)**. При етап 5 виждаме най-разгънатата фаза на рекурсията, на която се виждат всичките множители. Съответно последната фаза е етап 9, при която връщаме крайния резултат.

## **2. Рекурсивен срещу итеративен подход**

Вече се запознахме с дефиницията на рекурсията. Сега нека разгледаме какви са и предимствата и недостатъците. Всяка рекурсивна задача може да бъде написана с итеративен подход. При итеративния подход, ако спрем изпълнението на програмата по кое да е време, можем да видим какъв е резултата до момента.

Рекурсита може да ни спести време в писане на код и може да ни помогне за написването на някакъв алгоритъм или за решението на някаква задача използваща структури от данни, като например обхождане на дървета и графи. Поради чистотата на кода и семплият вид, някои задачи са по-подходящи да бъдат написани с рекурсивен подход.

От друга страна итеративния подход за написване на някои задачи би било по-добрия избор от рекурсивния подход. Това е така, защото за рекурсия ни е необходима много стекова памет, а както вече знаем, тя няма да се освободи, докато не приключи функцията изпълнението си.

Например, написването на рекурсивен подход на функцията „Фибоначи“, би било по-интуитивно, отколкото написването и с итеративен подход.

## **3. Видове рекурсия**

1. Линейна рекурсия

```cpp
int fact(int n)
{
    if (n <= 1) // base case
    {
        return 1;
    }

    //general case
    return n * factorial(n - 1);
}
```

2. Нелинейна рекурсия

```cpp
int fibunacci(int n)
{
	if (n < 0)
	{
		return -1;
	}
	else if (n == 0 || n == 1)
	{
		return n;
	}

	return fibunacci(n - 1) + fibunacci(n - 2);
}
```

3. Опашата рекурсия

```cpp
int betterFibunacci(int n, int prePrev, int prev)
{
	if (n == 0)
	{
		return prePrev;
	}

	return betterFibunacci(n - 1, prev, prePrev + prev);
```

4. Взаимна рекурсия

```cpp
//Example from GeeksForGeeks.org
void funB();

void funA(int n)
{
    if (n > 0)
    {
        sd::cout << " " << n;

        funB(n - 1);
    }
}


void funB(int n)
{
    if (n > 1)
    {
        std::cout << " " << n;

        funA(n / 2);
    }
}
```

В този случай функциите **funA** и **funB** се извикват взаимно. Трябва да се обърне внимание, че трябва да дефинираме функцията **funB** над **funA**, защото иначе ще получим компилационна грешка.
