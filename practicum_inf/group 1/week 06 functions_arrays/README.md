# Week 6. Масиви

## Масиви
Масивът е съвкупен тип данни, който ни позволява да осъществим достъп до много на брой, линейно наредени в паметта, променливи от един и същи тип чрез **идентификатор (име)**. Тези променливи се наричат елементи.

```c++
int workHoursPerson1;
int workHoursPerson2;
// ...
int workHoursPerson100;

// is essentialy equivalent to:
int workHours[100]; // allocate 100 integer variables in a fixed array
```

### Деклариране и инициализиране на масиви
За изграждането на масив най-важното което, трябва да определим е **броят на елементите** му и **техният тип**.
```C++
int arr[5]; // така декларираме масив от тип int с 5 елемента
char str[100];// така декларираме масив от тип char със 100 елемента
double dArr[10]; // така декларираме масив от тип double с 10 елемента
```

### Размер на масива
Сам по себе си от масива не може да се извлече неговият размер. Начини за разбиране на размера:
- Отделна променлива с размера `size`
- Да се разпознае края на масива (в края му се слага някаква предварително известна стойност)
- Задачата определя размера на масива (по условие е с предварително зададен размер)


### Инициализация на масиви

![Array with indexes](https://i1.faceprep.in/fp/articles/img/71860_1580541983.png)

```c++
// first way
int arr[5];
arr[0] = 5;
arr[1] = -3;
arr[2] = 12;
arr[3] = 6;
arr[4] = 123015;

// second way
int ex1[3] = {1, 2, 3};     // ex1 = [ 1, 2, 3 ]
int ex2[5] = {1, 2, 3};     // ex2 = [ 1 , 2 , 3 , 0 , 0 ]
int ex3[] = {1, 2, 3};      // ex3 = [ 1, 2, 3 ]
int ex4[5] = {0};           // ex4 = [ 0, 0, 0, 0, 0]
int ex5[3] = {1, 2, 3, 4};  // Unable to compile

const int ARR_SIZE = 10;
int e[ARR_SIZE];

// third way
double arr[5];
for (int i = 0; i < 5; ++i)
{
    cin >> arr[i];
}
```

### Допустими операции
Операции над цели масиви ***не са допустими***.

```c++
int a[5], b[5] = {1,2};
a = b;  // недопустима операция

// Достъпване на елементите на масив:
int arr[5] = { 1, 2, 3, 4, 5 };
int first = arr[0];
int last = arr[4];

arr[5]; // error index out of rante
arr[-1]; // бъркаме в чужда памет!
```

### Подаване на масив като аргумент на функция
Компилаторът знае как да разграничи константен от неконстантен масив. Когато не дадена функция няма да променя масива е хубаво да се използва `const`.
```C++
// arr is the actual array
// so changing it here will change the original argument!
void func(int arr[5]);

// even though arr is the actual array,
// within this function it should be treated as a constant
void func(const int arr[5]);

// If we want it not to be of fixed size:
void func2(int arr[], int size);
void func2(const int arr[], int size);
```

### Въвеждане и извеждане на елементите на масив
```c++
// въвеждане
double arr[5];
for(int i = 0; i < 5; i++)
{
    cout << "arr[ " << i << " ]= ";
    cin >> arr[i];
}

// извеждане
for(int i = 0; i < 5; i++)
{
    cout << "arr[ " << i << " ]= " << arr[i] << endl;
}
```

# Задачи

## :warning: Насоки :boom: 

- Давайте смислени имена на променливите си
- Целете се към максимално спазване на чист код 
- Правете валидация на входните си данни

## :zero: Задача :1234:
Да се напише функция, която приема цяло положително число n и връща ново число, което се състои от същите цифри, но в сортиран ред.

### Пример:
```C++
Вход: 531261
Изход: 112356
```

## :one: Задача :arrows_counterclockwise:
Да се напише функция, която разменя стойностите на две променливи от тип `int`.

### Пример:
```C++
The value of a is: 5
The value of b is: 7
The new value of a is: 7
The new value of b is: 5
```

## :two: Задача  :traffic_light:
Да се напише функция, която приема като аргумент дадено неотрицателно естествено число и го умножава с най-голямото, но не по-голямо от него, просто число. Ако са подадени числата 0 или 1, програмата да ги превръща в 666.

### Пример:
```C++
Вход: 25
Изход: 575 //Най-голямото просто число, което е по-малко от 25 е 23. 575 = 23 * 25
```

## :three: Задача :arrow_right_hook:
Създайте:
- Функция, която прочита размер на масив `n <= 100` и `n` цели числа от конзолата.
- Функция, която извежда масив от цели числа в конзолата.
- Функция, която извежда масив от цели числа в обратен ред.

## :four: Задача :space_invader:
Да се напише програма, която извежда числата от масив, които стоят на нечетна позиция.

### Пример:
```C++
Вход: 167205
Изход: 6 2 5
```

## :five: Задача :gem:
Напишете програма, която въвежда размер на масив `n <= 100` и прочита масива.
Направете функции за намиране на:
- индекса на най-малко число
- индекса на най-голямо число
- сумата на елементите
- средноаритметично на елементите

Демонстрирайте ги върху прочетения масив.

### Вход:
```C++
Size: 10
1 3 -5 0.4 1.17 55 0 -1.2 9.5 3.14
```
### Изход
```C++
Min number: -5
Max number: 55
Sum: 67.01
Average: 6.701
```

## :six: Задача
Да се напише функция, която извежда на екрана числата от масив, за които е изпълнено условието: Позицията на числото + числото да е равна на друго число от масива.

### Пример:
```C++
Вход: 3 4 2 5 7
Изход: 3 4 2
```

## :seven: Задача :leftwards_arrow_with_hook:
Напишете програма, която въвежда размер `n <= 100` на масив с естествени числа и прочита масива.
Направете функция за обръщане на масив, без да използвате втори масив.
Демонстрирайте я върху прочетения масив.
### Пример:
```C++
Вход:
10
2 1 2 10 15 1 5 5 3 9
Изход:
9 3 5 5 1 15 10 2 1 2
```

## :eight: Задача :hash:
Напишете програма, в която има константа MAX_NUM със стойност 10.
Използвайте алгоритъма [Решето на Ератостен](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) 
отпечатайте всички прости числа в интервала `[1, MAX_NUM]`.

### Пример:
При `MAX_NUM = 10`:
```C++
Prime numbers between 1 and 10:
2 3 5 7
```

### Пример:
При `MAX_NUM = 15`:
```C++
Prime numbers between 1 and 15:
2 3 5 7 11 13
```