# Практикум

## Какво научихме предния път?
* Mасиви
* Многомерни масиви

## Какво ще научим днес?
* Преговор на многомерни масиви
* Функции

## Многомерни масиви (Multidimensional array)
Масивът е структурен (съставен) тип данни, представляващ крайна редица от еднотипни елементи с **пряк достъп до всеки елемент**. 
**Многомерните масиви** обикновено се описват като **"масиви от масиви"**, но за да можем по-лесно да си го представим  
ще използваме двумерен масив, който прилича на таблица или матрица(като по алгебра :D). 
Многомерните масиви, също като едномерните, са съставени от един и същ тип данни(int, char, double, и др.).

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRep.jpeg)

Това е двумерен масив, който на С++, може да се декларира така: 
```c++
    int arr[3][5];
```
Този масив може да се разглежда като: **променлива(arr)** oт тип **int**, която съдържа ***3 масива от по 5 елемента***, 
или **матрица с 3 реда и 5 колони(по-често)**. 

### Декларане на масив
За изграждането на двумерен масив най-важното което, трябва да определим е **броят на елементите** му, **техният тип** и 
**броят на редовете и колоните**. Например:
```c++    
    int arr[3][5]; - така декларираме масив от тип int с 3 реда и 5 колони(общо 15 елемента)
    double dArr[10][10]; - така декларираме масив от тип double с 10 реда и 10 колони(общо 100 елемента)
    char str[4][6]; - така декларираме масив от тип char с 4 реда и 6 колони(общо 24 елемента)
```
Броят на **редовете и колоните** може да бъде зададен и **чрез константи**, които са **предварително дефинирани**.
```c++
    const int ROWS = 3;
    const int COLUMNS = 5;
        ...
    int array[ROWS][COLUMNS];
```

### Инициализация на масиви
#### Първи начин:
#    
```c++
    int arr[2][2]; // два реда и две колони, общо 2 * 2 = 4 елемента
    arr[0][0] = 5;
    arr[0][1] = -3;                 //arr изглежда така: 5 -3
    arr[1][0] = 12;                 //                   12 6
    arr[1][1] = 6;
```

#### Втори начин:
#
```c++
    int arr[3][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};
```
Нагледно е това:

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRepInit.jpeg) 

#### Втори начин':
Не е задължително да попълвате всички стойностти, както и да използвате вътрешните скоби за указване елементите на редовете. Въпреки че, някои компилатори ще ви позволят да пропуснете вътрешните скоби, ние силно препоръчваме да ги включите, така или иначе, както за целите на четливостта на кода, така и за начина, по който C++ ще замени липсващите стойности с 0.

```c++
int array[3][5] =
{
    { 1, 2  }, // row 0 = 1, 2, 0, 0, 0
    { 6, 7, 8 }, // row 1 = 6, 7, 8, 0, 0
    { 11, 12, 13, 14 } // row 2 = 11, 12, 13, 14, 0
};

```
#### Втори начин'':
Двумерните масиви с инициализиращи списъци от елементи, могат да **пропуснат само най-лявата** спецификация на дължината:
```c++
int array[][5] =
{
    { 1, 2, 3, 4, 5 },
    { 6, 7, 8, 9, 10 },
    { 11, 12, 13, 14, 15 }
};
```
Компилаторът може да разбере каква е дължината на масива. Въпреки това, **не се допуска** следното:
```c++
int array[][] = 
{
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 }
};
```
#### Трети начин:
Можем да  инициализираме двумерен масив и със стойности, въведени от клавиатурата.
```c++
    double arr[3][5];
    for(int i = 0; i < 3; i++)  // имаме 3 реда
    {
        for(int j = 0; j < 5; j++) // и 5 колони
        {
            cin >> arr[i][j];
        }
    }
```
### Достъп до елемент
Достъпът до всеки елемент се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) т.е. **номера на реда и на колоната, в която се намира елемента**, поставен в квадратни скоби.
```c++
    arr[1][3]; // индексирането в двумерни масиви, също е от 0 до броя на                     
                // елементите -1 в съответния ред или колона
```

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRepAccess.jpeg) 

### Допустими операции
Операции над цели двумерни масиви ***не са допустими***.

```c++
    int a[3][5], b[3][5];
    a = b;  // недопустима операция
```

### Въвеждане и извеждане на елементите на масив
#### Въвеждане:
#
```c++
    double arr[3][5];
    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 5; j++) 
        {
            cout << "arr[ " << i << " ][ " << j << " ]= ";
            cin >> arr[i][j];
        }
    }
```

#### Извеждане:
#
```c++
    double arr[3][5];
        ...
    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 5; j++)
        {
            cout << "arr[ " << i << " ][ " << j << " ]= " << arr[i][j] << ' ';
        }
        cout << endl;
    }
```

## Функции(Functions)
### Какво са функциите и за какво ги използваме
Функциите позволяват структуриране на програмата на сегменти, които да извършват индивидуални задачи. Можем да кажем и така: Функцията е група от оператори, на коята се дава име и може да бъде извикана в коя да е част от програмата ни.

Главните цели на функциите са:
 - да разделим изпълнението на главната ни задача на подзадачи (опростяване на заданието)
 - избягването на повторение на код
 - подобряване на четливостта на кода

### Основни понятия
Тук ще разграничаваме следното:
 - декларация (declaration) на функция - казва на компилатора за това, че съществува функция с: име, тип на връщане и параметри към функцията 
 - дефиниция (definition) на функция - тук е указва какво точно е тялото на функцията (т.е нейната реализация)

### Синтаксис
#### Основният синтаксис на функция, при нейната дефиниция е:

```c++
return_type function_name( parameter_list )
{
   body_of_the_function
}
```

където:
 - **return_type (върнат тип)** - посочва какъв ще е типът на върнатата стойност от функцията
 - **funtion_name** - това е името на функцията. Чрез него ще можем да се обръщаме към самата функция, когато искаме тя да се изпълни
 - **parameter_list** - списък от параметри, които се подават на функцията. Този списък не е задължителен, т.е можем да имаме функция, 
    която **не** приема параметри. Ако такъв съществува, то те са изписани по модела: **<тип> име | <тип> име = стойност**
 - **body_of_the_function (тяло на функцията)** - правилата, по които ще се изпълни дадената функция

Пример:
Ще направим програма, която ще намира сумата на две цели числа:

```c++
#include <iostream>

int sum(int numLeft, int numRight)
{
    return numLeft + numRight;
}

int main()
{
    int result = 0; // добра практика е да се инициализира стойността при създаване, за да не се запълва с някаква случайна стойност

    result = sum(4, 5);

    std::cout << "Sum = " << result;

    return 0;	
}
```

Тази функция ни казва следното: **типа на върнатата стойност** ще бъде тип **int**, **името на функцията е sum** и тя ще **приема две цели числа.** В главната функция (main функцията) създаваме променлива, в която ще запаметим резултата от сумирането. Обърнете внимание, че използвам същия тип като на функцията (int). Трябва да подадем две стойностти на функцията в случая са 4 и 5. След това изкарвам резултата, който в случая е 9.

### Декларация на функция
Декларирането на функция единствено казва на компилатора, че имаме дадена функция, без да казва как е реализирана тя.

Пример:

```c++
return_type function_name( parameter list);
int sum(int numLeft, int numRight);
```

Така нашата програма ще знае, че съществува функцията sum, която има два параметъра, но до там. Как е реализирана функцията, трябва да кажем допълнително. При някой конвеции на езика е препоръчително декларацията да се намира **преди main функцията**.

### Дефиниция на функция
Дефинирането на функция всъщност е точно това допълнителноо нещо, което казваме на компилатора. Дефиницията представлява реализация на функцията или по-просто казано, това е **съдържанието на тялото** на функцията - функционалността на функцията.

Пример:
```c++
int sum(int numLeft, int numRight)
{
    return numLeft + numRight;
}
```

Пример за използване на декларация и дефиниция:

```c++
#include <iostream>

int sum(int numLeft, int numRight);

int main()
{
    int result = 0; // добра практика е да се инициализира стойността при създаване, 
    		    // за да не се запълва с някаква случайна стойност

    result = sum(4, 5);

    std::cout << "Sum = " << result;

    return 0;	
}

int sum(int numLeft, int numRight)
{
    return numLeft + numRight;
}
```
Така казваме, че има функция sum и при изввикването и в главната функция, програмата ще търси къде е дефиницията на тази функция. 

### NB!: Функциите, които казваме, че връщат тип винаги имат **return <type_component>;**
Какво точно казва това?
Когато казваме, че функцията трябва да върне реален тип, то се очаква, че ще има някъде във функцията операторът return. Той казва, че се прекратява изпълнението на функцията и ще се върне стойността която му е зададена вдясно от него.

Пример:
```c++
   return (5 + 9);
```
Ще върне целочислен резултат 14 (стига до return, смята стойността на израза и го връща като резултат)

След return може да имате и по - сложни изрази.
Пример:

```c++
bool isEven(int number) 
{
  return (number % 2 == 0 ? true : false);
}

float someWeirdFunction(float number) 
{
  return (number + 365 - sin(45));
}
```



### Функции, които не връщат стойност
Това са функции, чието предназначение **не очертава връщането на стойност.** Те се използват, когато искаме да въведем/променим дадена стойност или да изведем съобщение. **В тези функции пропускаме оператора return**. Разбира се, не е изключено да го използваме. Когато го използваме връщаме **нищо**-празен оператор, т.е стигаме до оператор **return;**, който прекратява изпълнението на функцията и не връща стойност. (не забравяйте, че завършва с ;)

Пример:
```c++
void message()
{
   std::cout << "This is message\n";
}

void someFunction()
{
	if (true)
	{
		std::cout << "True";
		return ;
	}
    	else
	{
		std::cout << "False";
		return ;
	}
	
	std::cout << "This will never show on screen";	
}
```

В someFunction никога няма да се покаже последното съобщение, защото и в двата случая на логическото условие сме дали return; което ще прекрати изпълнението на функцията.

Пример с всичко до тук (програмата има само образователна цел):
```c++

#include <iostream>

int input(); // въвежда полочително число
int sum(const int numLeft, const int numRight); // извършва сумиране на числата

bool isNegative(int number); // проверява дали числото е отрицателно. Тип на връщане - bool

void message(); // Съобщение
void output(int number); // Изход с число
void lego(); // сглобяване

int main()
{
    lego();
    
    return 0;	
}

int input()
{
    int tmp;

    do
    {
        message();
        
        std::cin >> tmp;
    }while(isNegative(tmp));
    
    return tmp;
}

bool isNegative(int number)
{
    return number < 0;
}

void message()
{
    std::cout << "Number must be positive\n";
}

int sum(const int numLeft, const int numRight)
{
    return (numLeft + numRight);
}

void output(int number)
{
    std::cout << "Result = " << number << std::endl;
}

void lego()
{
    int numLeft = 0, numRight = 0;
    
    numLeft = input();
    numRight = input();
    
    output(sum(numLeft, numRight));
}
```

Нека обърнем малко внимание на подаването на параметри във функции.
В горните примери видяхме, че при извикване на функция с параметри трябва да ги подадем, като реда на подаване има значение, т.е:

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week09/diagrams/pic1.jpg)

### Подаване на масив като параметър на функция
#### Синтаксис за едномерен масив

	return_type/void <function_name>( <type> <name>[], <integer_type> <size>);

Пример:
```c++
int sumAllElementsInArray(int arr[], int size);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_arr[5] = {1, 2, 3, 4, 5};
	...
	cout << sumAllElementsInArray(my_arr, 5);
```
#### Синтаксис за двумерен масив

	return_type/void <function_name>( <type> <name>[][<maximum_size_of_columns>], <integer_type> <size_of_rows>, <integer_type> <size_of_rows>);

Пример:
```c++
int sumAllElementsInMatrix(int mrx[][10], int rowSize, int columnSize);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_mrx[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	...
	cout << sumAllElementsInMatrix(my_mrx, 3, 3);
```
