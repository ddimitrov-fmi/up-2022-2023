## Какво ще научим днес?
* структурни типове данни
* едномерни масиви
* многомерни масиви

## Структурни типове данни
Когато е необходимо да пазим и обработваме количествена информация(например: работните часове на 100 работника в някоя фирма) вместо да използваме 100 различни променливи и да помним коя за кой работник се използва, можем да използваме структурни(още съставни) типове данни.

## Масиви(Arrays)
Масивът е структурен (съставен) тип данни, представляващ крайна редица от **еднотипни елементи** с **пряк достъп до всеки елемент**. Масивът е съвкупен тип данни, който ни позволява да осъществим достъп до много променливи от един и същи тип чрез **идентификатор**. В декларацията на масива използваме квадратни скоби ([]), за да кажем на компилатора, че това е *променлива от тип масив*(вместо нормална променлива), както и колко последователни(по адреси) клетки("променливи") да се заделят в паметта(наречени дължина на масива). 

```c++
int hours[100];
```

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week06/diagrams/memory.png)

### Памет (Memory)
Паметта е поредица от клетки, всяка от които има свой размер и адрес. Когато казваме *колко клетки("променливи") да се заделят в паметта*, имаме предвид че, в паметта трябва да има толкова свободни клетки, със съответния размер на типа на масива(променливите от този тип), колкото ние сме посочили, че да може да заемем. Например, aко пазим работните часове на 100 работника, в паметта масивът ни ще изглежда като на картинката горе. 


#### Паметта, която можете да използвате в C++ програма е най-общо казано три типа:
* статична

в тази памет се записват променливите, обявени извън функциите (т.нар. глобални променливи). Те се виждат от всички функции през цялото изпълнение на програмата
* стекова

в тази памет се записват предадените параметри и променливите дефинирани вътре във функциите и въобще в произволен блок. Променливите се виждат само във функцията (блока) в която са дефинирани и се унищожават при завършване на функцията (излизане от блока)
* динамична

останалата част от паметта на компютърна е достъпна до всички програми при поискване. За управлението на тази памет се грижи операционната система  . Във всеки момент отделен блок от паметта може да е свободен или да е заделен за някоя програма, при която може да го чете само тя. При опит някоя програма да прочете памет, която не е заделена за нея, независимо дали е заделена за друга програма или е свободна, операционната система прекратява изпълнението на програмат с грешка Access Violation


### Декларане на масив
За изграждането на масив най-важното което, трябва да определим е **броят на елементите** му и **техният тип**.
​    
    int arr[5]; - така декларираме масив от тип int с 5 елемента
    double dArr[10]; - така декларираме масив от тип double с 10 елемента
    char str[100]; - така декларираме масив от тип char със 100 елемента

Броят на елементите може да бъде зададен и чрез константа, която е предварително дефинирана;
```c++
    const int n = 3;
    long array[n];
```
Достъпът до всеки елемент се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) поставен в квадратни скоби.
```c++
    array[0]; // индексирането в масиви е от 0 до (броя на елементите - 1)
```
### Инициализация на масиви
##### Първи начин:

```c++
    int arr[5];
    arr[0] = 5;
    arr[1] = -3;
    arr[2] = 12;
    arr[3] = 6;
    arr[4] = 123015;
```

##### Втори начин:

```c++
    int arr[5] = {5, -3, 12, 6, 123015};
```

##### Трети начин:

```c++
    int arr[] = {5, -3, 12};
```

##### Четвърти начин:
Можем да  инициализираме масив и със стойности, въведени от клавиатурата.
```c++
    double arr[5];
    for(int i = 0; i < 5; i++)
        cin >> arr[i];
```

### Допустими операции
Операции над цели масиви ***не са допустими***.

```c++
    int a[5], b[5] = {1,2};
    a = b;  // недопустима операция
```

### Въвеждане и извеждане на еменетите на масив
#### Въвеждане:

```c++
    double arr[5];
    for(int i = 0; i < 5; i++)
    {
        cout << "arr[ " << i << " ]= ";
        cin >> arr[i];
    }
```

#### Извеждане:

```c++
    double arr[5];
        ...
    for(int i = 0; i < 5; i++)
    {
        cout << "arr[ " << i << " ]= " << arr[i] << endl;
    }
```

## Символен низ(C-Style string/string)
Масив от тип char се нарича  **символен низ**. 
Примери:
​    
     "Informacionni sistemi"
     "My name is Mery"
     "" // празен низ
     "My name" // подниз на "My name is Mery"

Низовете се използват за образуване на изречения на някой език, обработка на текстове, кодиране на информация, кодиране на команди и други.

### Декларане на символен низ
При декларирането на низ, трябва да се предвиди място за още един символ: \0 - null символ(означава край на низ). Този символ не се отпечатва, той просто дава нужната информация на компилатора.

    char str[100]; - така декларираме масив от тип char със 100 елемента

Броят на емементите може да бъде зададен и чрез константа, която е предварително дефинирана;
```c++
    const int SIZE = 3;
    char key[SIZE];
```
**Достъпът** до всеки елемент, както при другите масиви, се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) поставен в квадратни скоби.
```c++
    key[0]; // индексирането в масиви е от 0 до броя на елементите -1
```

### sizeof()
Sizeof е оператор, който ни показва колко памет(в байтове) заема дадена променлива от съответен тип. 
```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "bool:\t" << sizeof(bool) << " bytes" << endl;
    cout << "char:\t" << sizeof(char) << " bytes" << endl;
    cout << "short:\t" << sizeof(short) << " bytes" << endl;
    cout << "int:\t" << sizeof(int) << " bytes" << endl;
    cout << "long:\t" << sizeof(long) << " bytes" << endl;
    cout << "float:\t" << sizeof(float) << " bytes" << endl;
    cout << "double:\t" << sizeof(double) << " bytes" << endl;
    cout << "long double:\t" << sizeof(long double) << " bytes" << endl;
    
    return 0;
}
    
```

	bool:		1 bytes
	char:		1 bytes
	short:		2 bytes
	int:		4 bytes
	long:		8 bytes
	float:		4 bytes
	double:		8 bytes
	long double: 	16 bytes

Когато използваме sizeof() върху масив, отново получаваме размера в байтове. Например, ако масива ни е от тип char и е с големина 100 елемента, то неговият размер е 100 елемента * 1 байт = 100 байта.
```c++
#include <iostream>
using namespace std;

int main()
{
    int arr[100];
    char str[100];
	
    cout << sizeof(arr) << " bytes" << endl;
    cout << sizeof(str) << " bytes" << endl;
    
    return 0;
}
```

## Многомерни масиви (Multidimensional array)
Масивът е структурен (съставен) тип данни, представляващ крайна редица от еднотипни елементи с **пряк достъп до всеки елемент**. 
**Многомерните масиви** обикновено се описват като **"масиви от масиви"**, но за да можем по-лесно да си го представим, 
ще използваме двумерен масив, който прилича на таблица или матрица(като по алгебра :D). 
Многомерните масиви, също като едномерните, са съставени от един и същ тип данни(int, char, double, и др.).

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRep.jpeg)

Това е двумерен масив, който на С++, може да се декларира така: 
```c++
    int arr[3][5];
```
Този масив може да се разглежда като: **променлива(arr)** oт тип **int**, която съдържа ***3 масива от по 5 елемента***, 
или **матрица с 3 реда и 5 колони(по-често)**. 

### Декларане на масив
За изграждането на двумерен масив най-важното което, трябва да определим е **броят на елементите** му, **техният тип** и 
**броят на редовете и колоните**. Например:
```c++    
    int arr[3][5]; - така декларираме масив от тип int с 3 реда и 5 колони(общо 15 елемента)
    double dArr[10][10]; - така декларираме масив от тип double с 10 реда и 10 колони(общо 100 елемента)
    char str[4][6]; - така декларираме масив от тип char с 4 реда и 6 колони(общо 24 елемента)
```
Броят на **редовете и колоните** може да бъде зададен и **чрез константи**, които са **предварително дефинирани**.
```c++
    const int ROWS = 3;
    const int COLUMNS = 5;
        ...
    int array[ROWS][COLUMNS];
```

### Инициализация на масиви
#### Първи начин:
#    
```c++
    int arr[2][2]; // два реда и две колони, общо 2 * 2 = 4 елемента
    arr[0][0] = 5;
    arr[0][1] = -3;                 //arr изглежда така: 5 -3
    arr[1][0] = 12;                 //                   12 6
    arr[1][1] = 6;
```

#### Втори начин:
#
```c++
    int arr[3][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};
```
Нагледно е това:

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRepInit.jpeg) 

#### Втори начин':
Не е задължително да попълвате всички стойностти, както и да използвате вътрешните скоби за указване елементите на редовете. Въпреки че, някои компилатори ще ви позволят да пропуснете вътрешните скоби, ние силно препоръчваме да ги включите, така или иначе, както за целите на четливостта на кода, така и за начина, по който C++ ще замени липсващите стойности с 0.

```c++
int array[3][5] =
{
    { 1, 2  }, // row 0 = 1, 2, 0, 0, 0
    { 6, 7, 8 }, // row 1 = 6, 7, 8, 0, 0
    { 11, 12, 13, 14 } // row 2 = 11, 12, 13, 14, 0
};

```
#### Втори начин'':
Двумерните масиви с инициализиращи списъци от елементи, могат да **пропуснат само най-лявата** спецификация на дължината:
```c++
int array[][5] =
{
    { 1, 2, 3, 4, 5 },
    { 6, 7, 8, 9, 10 },
    { 11, 12, 13, 14, 15 }
};
```
Компилаторът може да разбере каква е дължината на масива. Въпреки това, **не се допуска** следното:
```c++
int array[][] = 
{
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 }
};
```
#### Трети начин:
Можем да  инициализираме двумерен масив и със стойности, въведени от клавиатурата.
```c++
    double arr[3][5];
    for(int i = 0; i < 3; i++)  // имаме 3 реда
    {
        for(int j = 0; j < 5; j++) // и 5 колони
        {
            cin >> arr[i][j];
        }
    }
```
### Достъп до елемент
Достъпът до всеки елемент се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) т.е. **номера на реда и на колоната, в която се намира елемента**, поставен в квадратни скоби.
```c++
    arr[1][3]; // индексирането в двумерни масиви, също е от 0 до броя на                     
                // елементите -1 в съответния ред или колона
```

![alt text](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week07/diagrams/matrixRepAccess.jpeg) 

### Допустими операции
Операции над цели двумерни масиви ***не са допустими***.

```c++
    int a[3][5], b[3][5];
    a = b;  // недопустима операция
```

### Въвеждане и извеждане на елементите на масив
#### Въвеждане:
#
```c++
    double arr[3][5];
    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 5; j++) 
        {
            cout << "arr[ " << i << " ][ " << j << " ]= ";
            cin >> arr[i][j];
        }
    }
```

#### Извеждане:
#
```c++
    double arr[3][5];
        ...
    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 5; j++)
        {
            cout << "arr[ " << i << " ][ " << j << " ]= " << arr[i][j] << ' ';
        }
        cout << endl;
    }
```
