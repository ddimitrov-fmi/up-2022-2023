

## Какво научихме предния път?
* Функции

## Какво ще научим днес?
* Указатели и референции
* Указатели и масиви
* Функции(advanced level)

## Указатели и референции (Pointers and References)
### За какво са и за какво ни трябват?
В началото, когато разбрахме какво са променливите, ние отбелязахме, че променлива е име(идентификатор) за клетка от паметта, която съдържа стойност. Когато нашата програма създава променлива, свободнен адрес на клетка в паметта автоматично се присвоява на променливата и всяка стойност, която даваме на променливата се съхранява в този адрес на паметта.

Например:
```c++
	int x;
```
Когато тази опрерация се изпълнява, CPU отделя част от RAM паметта с размер 4 байта. За примера, нека кажем, че променливата x е сложена на адрес 140 в паметта. Когато програмата вижда променливата x в израз, тя знае, че тя трябва да търси адрес 140 в паметта, за да намери стойността на х. Хубавото за променливите е, че не е нужно да се тревожим за това кой специфичен адрес в паметта е даден. Ние се обръщаме към променливата по дадения й идентификатор и компилаторът превежда това име в подходящо определен адрес в паметта. 

#### За любознателните:
Всички компютри имат памет, известна също като RAM (random access memory). Например, компютърът ви може да има 16, 32, 64 и повече мегабайта RAM(днес вече говорим за гигабайти). RAM паметта съхранява програмите, които компютърът ви изпълнява заедно с данните, които те използват(променливи и структури от данни). Паметта може да се представи просто като масив от байтове. В този масив всяка клетка на паметта има свой собствен адрес - адресът на първия байт е 0, последван от 1, 2, 3 и т.н. Адресите на паметта действат точно като индексите на нормален масив. Компютърът има достъп до всеки адрес в паметта по всяко време (оттук и името "памет с произволен достъп"). Тя също така, може да групира байтове заедно, за да формира по-големи променливи, масиви или структури. Например, променлива с плаваща запетая консумира в паметта 4 съседни байта. 

#### Address-of оператор (&)
Address-of(**&**) оператора ни позволява да видим **кой адрес в паметта е присвоен на променлива**. 
Пример:
```c++
#include <iostream>
using namespace std;

int main()
{
    int x = 5;
    cout << x << endl; // ще изведе стойността на х
    cout << &x << endl; // ще изведе адреса в паметта на х
 
    return 0;
}
```
Изход:

	5
	0x7822221582fc

#### Value-of оператор (\*)
Получаването на адреса на променлива не е много полезно само по себе си. Операторът value-of (\*) ни позволява да **получим стойността съхранявана на определен адрес в паметта.**
```c++
#include <iostream>
using namespace std;

int main()
{
    int x = 5;
  	int *ptrX = &x;
    cout << x << endl; // ще изведе стойността на х
    cout << &x << endl; // ще изведе адреса в паметта на х
    cout << *ptrX << endl; // ще изведе стойността, съхранявана в клетката с адреса на х
 
    return 0;
}
```
Изход:

	5
	0x7822221582fc
	5

### Указатели (Pointers)
Указателят е **променлива**(NВ! има тип!), която **съхранява адрес в паметта като стойност**. Както променливата от тип int съхранява цяло число, или както променливата от тип bool съхранява true или false, така и указателят съхранява адрес от вида 0x7822221582fc(16-тична бройна система).

#### Декларация на указател
Указателите се **декларират като обикновени променливи**, с изключение на това че, се поставя символ **\* между типа и името на указателя.**
```c++

int *iPtr; // указател към променлива от тип int
double *dPtr; // указател към променлива от тип double
 
int* iPtr2; // това също е валидно, но го избягвайте
int * iPtr3; // това също е валидно, но го избягвайте
 
int *iPtr4, *iPtr5; // два указателя към променливи от тип int
```
При деклариране на няколко указателя, към всеки указател трябва да бъде сложена нова \*. *Лесно е да забравите да направите това, ако свикнете да прикрепите звездичката към типа, вместо към името на променливата!*
```c++
int * iPtr6, iPtr7; // iPtr6 е указател към int, а iPtr7 е просто обикновен int!
```
#### Инициализация
##### Синтаксис и семантика:
```c++
<object_type> *<object_name_pointer> = &<object_name_transmitter>;
```
Пример:
```c++
int a = 50;
int *ptr = &a;
```
По този начин правим следното: създали сме променлива от тип int и сме я инициализирали със стойност 50, след това създаваме променлива от тип указател към int на когото присвояваме адреса на а. Вземането на адрес на дадена променлива се прави чрез &(както казахме по-горе). **Най - важното е да се разбере, че указателите пазят адреса към паметта на това, с което искаме да оперираме.**

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week10/diagrams/MemoryPointer.png)

Пример:
```c++
int a = 50;
int *ptr = &a;

std::cout << *ptr << std::endl; // 50
std::cout << ++*ptr << std::endl; // 51
std::cout << a << std::endl; // 51

```
#### Нулеви стойности и нулеви указатели

Точно като нормалните променливи, указателите **могат да не се инициализират в началото**. Ако не е присвоена стойност на указателя, то той ще сочи някой **адрес по подразбиране.** Освен адресите на паметта, съществува още една допълнителна стойност, която указателят може да съдържа: **нулева стойност(null value)**. Нулевата стойност е специална стойност, която означава, че **указателят не сочи нищо/никъде.** Ако стойността на указателя е нулевата стойност, то указателят се нарича **нулев указател(null pointer).**

```c++
int *ptr(0);  // ptr е null pointer
 
int *ptr2; // ptr2 не е инициализиран
ptr2 = 0; // ptr2 вече е null pointer
```
Тъй като **нулев указател** се оценява с 0, то той **може да се използва в условенни изрази и конснтрукции**, за да се провери дали указателят е нулев указател или не.

#### Const
Досега всички указатели, които виждяхме бяха **неконстантни** указатели към **неконстантни** стойности:
```c++
int value = 5;
int *ptr = &value;
*ptr = 6; // променяме стойността на 6
```
Какво обаче се случва, ако имаме const int value?
```c++
const int value = 5; // value е константа
int *ptr = &value; // compile error: cannot convert const int* to int*
*ptr = 6; // променяме стойността на 6 (невъзможна стъпка)
```
Горният фрагмент няма да се компилира - не можем да зададем указател без const за стойност c const. Това има смисъл: const value е променлива, чиято стойност не може да бъде променена. Ако можем да зададем **неконстантен указател** на константна стойност, тогава чрез **value-of оператора** ще можем да променим стойността. Това би нарушило идеята на const като цяло. Затова има няколко много важни правила кога и как да се използват константи и указатели.

##### Указател към константа
Указател към константа е **неконстантен указател**, който сочи към **постоянна стойност**. Постоянната стойност не може да бъде променяна, независимо дали е дефинирана като константа или променлива.
###### Синтаксис

	const <type> *<name> = &<value>
	value - е константа или променлива, която не може да променя стойността си чрез указателя
Пример:
```c++
const int value = 5;
const int *ptr = &value; // ptr сочи към "const int"
*ptr = 6; // Не е позволено, защото сочи към константа
```
Нека обърнем внимание и на следния пример:
```c++
int value = 5; // value не е константа !!!
const int *ptr = &value; // ptr сочи към "const int" и все още е валидно
*ptr = 6; // Не е позволено, защото сочи към константна 
value = 6; // Обаче е позволено, защото достъпваме променливата чрез нейния идентификатор
```
**Указател към константа може да сочи към неконстантна стойност(променлива).** Мислете за това по следния начин: **указател към константа** се отнася към стойността, като към константа, независимо от това дали първоначално е била определена като константа или променлива.

Тъй като **указател към константа не е константен указател**(той просто сочи към постоянна стойност), указателя може да бъде пренасочен към други стойности:
```c++
int value1 = 5;
const int *ptr = &value1; // ptr сочи към "const int"
 
int value2 = 6;
ptr = &value2; // okay, сега ptr сочи към нова стойност "const int"
```
**Обобщено: При указател към константа, стойността, към която сочи, не може да бъде променяна чрез указателя.**
##### Константен указател
Също така можем да направим самият указател константен(постоянен). Константният указател е **указател, чиято стойност не може да се променя след инициализация**. За да декларирате константен указател, използвайте ключовата дума **const между \* и името на указателя:**
###### Синтаксис:

	<type> *const <name> = &<value>
	value - е променлива
Пример:
```c++
int value = 5;
int *const ptr = &value;
```
Точно като нормална константа, константния указател **трябва да се инициализира със стойност при декларацията си**. Това означава, че **константният указател винаги ще сочи един и същ адрес**. В горния случай ptr винаги ще сочи адреса на value. 
```c++
int value1 = 5;
int value2 = 6;
 
int * const ptr = &value1; // okay, константния указател ptr е инициализиран с адреса на value1
ptr = &value2; // not okay, веднъж инициализиран, не може да сочи другаде(да бъде променян)
```
Въпреки това, тъй като стойността, към която сочи, все още не е константа, е възможно да се **промени стойността**, която се сочи.
```c++
int value = 5;
int *const ptr = &value; // ptr винаги ще сочи към адреса на value
*ptr = 6; // позволено, сочи към променлива
```
**Обобщено: При константен указател, адреса, който той съхранява, не може да бъде променян. Но стойността на клетката с този адрес може да бъде променяна.**
##### Константен указател към константа
И най-накрая, възможно е да се дефинира константен указател към константна стойност с помощта на ключовата дума const, **както преди типа, така и преди името на променливата:**
###### Синтаксис

	const <type> *const <name> = &<value>
	value - е константа или променлива, която не може да променя стойността си чрез указателя
Пример:
```c++
int value = 5;
const int *const ptr = &value;
```
Константния указател към константа **не може да бъде пренасочен към друг адрес, нито пък стойността, която сочи, да бъде променена чрез указателя(независимо дали сочи константа или променлива).**

**Обобщено: При константен указател към константа, адресът и стойността на клетката не могат да бъдат променяни.**
#### Трябва само да запомните 4 правила и те са доста логични:

* Неконстантен указател, може да бъде пренасовчан към други адреси
* Константният указател, сочи към един и същ адрес, и този адрес не може да бъде променян
* На указател към неконстантна стойност може да се променя стойността, която той сочи. Те не могат да сочат към константа.
* Указател към константна стойност се отнася към стойността като към константа(дори и да не е), и по този начин не може да се промени стойността, която те сочат.

```c++
int value = 5;
const int *ptr1 = &value; // ptr1 сочи към "const int", това е указател към константа
int *const ptr2 = &value; // ptr2 сочи към "int", това е константен указател, към неконстантна стойност(променлива)
const int *const ptr3 = &value; // ptr3 сочи към "const int", това е константен указател към константа
```
### Референции (References) (наричат се още псевдоними)
Досега обсъдихме два основни вида променливи:
* Нормални променливи, които съхраняват информация директно. 
* Указатели, които съхраняват адреса на дадена стойност (или нула) и може да бъде използван за извличане на стойността на адреса, към който сочат.
  Референциите са третият основен тип променливи, който C++ поддържа. Референцията е **променлива, която действа като псевдоним на друг обект или стойност.**
#### Декларация на референция
Референция се декларира, като се използва **символът & между типа на референцията и името на променливата:**
```c++
int value = 5; // нормално цяло число
int &ref = value; // псевдоним на променливата value
```
**В този контекст & не означава "адресът на", а означава "псевдонимът на".**
Референциите обикновено действат идентично на стойностите, към които се отнасят. В този смисъл реферирането действа като псевдоним на обекта, за който се отнася. Тоест, **каквото правим с референцията, се отразява на променливата и обратното.**
Пример:
```c++
#include <iostream>
using namespace std; 
int main()
{
    int value = 3; // Нормално цяло число
    int &ref = value; // Псевдоним на променливата value
 
    value = 5; // value вече е 5
    ref = 13; // value вече е 13
 
    ++value;
    cout << value << endl;
    ++ref;
    cout << value << endl;
 
    return 0;
}
```
Изход:

	14
	15

Както виждаме, компилатора се отнася към value и ref като към синоними. Освен това, когато приложим "address-of" оператора към ref, ние получаваме адреса на value:
```c++
#include <iostream>
using namespace std;

int main()
{
    int value = 3; // Нормално цяло число
    int &ref = value; // Псевдоним на променливата value
 
    cout << &value << endl;
    cout << &ref << endl;

    return 0;
}
```
Изход:

	0x71d7e3331a1c
	0x71d7e3331a1c

* Референциите трябва да бъдат инициализирани, при създаването си.

   int &ref = value; 

* Неконстантните референции, могат да бъдат инициализирани само с неконстантни стойности(променливи).

   int value = 3; // Нормално цяло число
    		int &ref = value; // Псевдоним на променливата value

* Веднъж инициализирана, референцията не може да бъде псевдоним на друга променлива. А просто взима стойността й.

   int value2 = 5;	// Нормално цяло число
   	ref = value2; // value получава стойността на value2, т.е value = 5
* За разлика от указателите, които могат да сочат(съдържат) нулева стойност, няма такова нещо като нулева референция.

#### Връзка с указателите
Референциите и указателите имат интересна връзка - референцията действа като указател, който се използва за достъп до променливата.
```c++
int value = 5;
int *const ptr = &value;
int &ref = value;
```
* ptr и ref се оценяват по един и същ начин. В резултат на това, следните две твърдения са еквивалентни:
```c++
*ptr = 5;
ref = 5;
```
Референциите, обикновено, са много по-безопасни от указателите. Въпреки това, те също са малко по-ограничени в функционалност съответно.
Ако дадена задача може да бъде решена с референция или с указател, по принцип трябва да се предпочита референцията. Указателите трябва да се използват само в ситуации, при които референциите не са достатъчни (като динамично заделяне на памет).

#### Const
##### Референция към константа(или още константен псевдоним(Не се бъркайте с указатели, там са 2 различни неща!))
Точно както е възможно да се декларира иказател към константна стойност, също е възможно да се декларира референция към константна стойност. Това се прави чрез деклариране на псевдоним с помощта на ключовата дума const.
```c++
const int value = 5; // константа от тип int
const int &ref = value; // ref е псевдоним на константата value
```
###### Инициализация
```c++
int x = 5;
const int &ref1 = x; // okay, x е променлива
 
const int y = 7;
const int &ref2 = y; // okay, y е константа
```
Подобно на указател към константа, **референция към константа може да реферира неконстантна стойност(променлива).** При достъп, чрез референцията, стойността се счита за константна, дори ако оригиналната стойност не е, следователно не можем да я променим.
```c++
int value = 5; // Обикновена променлива
const int &ref = value; // псевдоним към константна стойност на value
 
value = 6; // okay, value не е константа
ref = 7; // not okay, ref е "константен псевдоним"
```
**Обобщено: При референция към константна стойност, стойността(константна или не), достъпвана чрез псевдонима, не може да се променя. Може да се променя самата променлива.

### Указатели и масиви
Споменахме ли, че масивът е "указател"? Трудно е да повявате? Създайте масив (да кажем от double), след това напишете:
```c++
double arr[5] = { 4, 5, 6, 7.6, 9 };
std::cout << arr << std::endl; // Ще се изпише на конзолата: 0x7ffcd4326470 
int *ptr = arr;
std::cout << ptr << std::endl; // Ще се изпише на конзолата: 0x7ffcd4326470
```
Това е така, защото **когато създаваме масив ние всъщност създаваме указател към първия елемент на масива** и когато казваме arr[index] (еквивалентно на \*(arr + index)) казваме дай ми елементът, който се намира на позицията на: адреса на първия елемент + отместване. На пръв поглед изглежда, че мавив и указател са едно и също. Но те не са. Основната разлика се илюстрира при използване на оператора sizeof(). Когато се използва върху масив, sizeof връща размера на целия масив (дължина на масива * размера на типа на елемента). Когато се използва върху указател сочещ масив, sizeof връща размера на адресa в паметта(в байтове). Следната програма илюстрира това:
```c++
#include <iostream>
using namespace std; 
int main()
{
	int array[5] = {1, 2, 3, 4, 5};
 
	cout << sizeof(array) << endl; // ще принтира sizeof(int) * дължината на масива
 
        int *ptr = array;
        cout << sizeof(ptr) << endl; // ще принтира размера на указателя
 
	return 0;
}
```
Изход:

	20
	4

**Масивът(разглеждан като указател към първия елемент) сам за себе си знае колко е дълъг(нали използваме [], за да му го кажем). Указател, сочещ масива не го знае, знае само къде започва.**
Е, вече имаме едно доказателство, което не потвърждава равенството. Следователно отхвърляме твърдението, че масив и указател са едно и също нещо.
#### Адресна аритметика
Езикът C++ ни позволява да извършваме операции за добавяне или изваждане на адреси от указателя. Ако ptr сочи към цялото число, ptr + 1 е адреса на следващото цяло число в паметта след ptr. А ptr - 1 е адресът на предишното цяло число преди ptr. Имайте предвид, че ptr + 1 не връща адреса на паметта след ptr, а адреса на паметта на следващия обект от типа, към който сочи ptr. Ако ptr сочи към цяло число (4 байта), ptr + 3 означава 3 цели числа (12 байта) след ptr. Ако ptr сочи знак, който винаги е 1 байт, ptr + 3 означава 3 символа (3 байта) след ptr.
```c++
#include <iostream>
 
int main()
{
    int value = 7;
    int *ptr = &value;
 
    std::cout << ptr << '\n';
    std::cout << ptr+1 << '\n';
    std::cout << ptr+2 << '\n';
    std::cout << ptr+3 << '\n';
 
    return 0;
}
```
Изход:

	0x7df9abb0acbc
	0x7df9abb0acc0
	0x7df9abb0acc4
	0x7df9abb0acc8

Може също директно да извадите 2 адреса(например началото и края на масив), като така получавате броя клетки от първия(вкл.) до втория адрес.
```c++
int main()
{
    int values[5] = {11, 38, 99, 4, 7};
    int *ptr = values;
    int *ptr2 = values + 4;
 
    std::cout << ptr2 - ptr << '\n';
     
    return 0;
}
```
Изход:

	4
Как можем да използваме това? Както споменахме в преди. Масивът е **поредица от еднотипни променливи(елементи)**, които се съхраняват **последователно** в паметта. След това видяхме, че **името на масива е указател към първият му елемент**. Сега видяхме, че с указателите могат да се извършват **операции по добавяне и изваждане** на брой клетки от дадена клетка. Сега ще използваме всичко това за да итерираме в масива, не чрез индекси, а чрез указатели.
```c++
#include <iostream>
using namespace std; 
int main()
{
     int array [5] = {9, 4, 5, 3, 8};
 
     cout << &array[1] << '\n'; // ще изведе адреса в паметта на втория елемент на масива
     cout << array+1 << '\n'; // ще изведе адреса в паметта на втория елемент на масива 
 
     cout << array[1] << '\n'; // ще изведе 4
     cout << *(array+1) << '\n'; // ще изведе 4 () са задължителни
 
    return 0;
}
```
Следователно **array[1] и \*(array + 1) ** са напълно еквиваленти.

##### Подаване на масив като параметър на функция(разширение)
#### Синтаксис за едномерен масив

	return_type/void <function_name>( <type> <name>[], <integer_type> <size>);
	return_type/void <function_name>( <type> *<name>, <integer_type> <size>);

Пример:
```c++
int sumAllElementsInArray(int arr[], int size);
int sumAllElementsInArray(int *arr, int size);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_arr[5] = {1, 2, 3, 4, 5};
	...
	cout << sumAllElementsInArray(my_arr, 5);
```
#### Синтаксис за двумерен масив

	return_type/void <function_name>( <type> <name>[][<maximum_size_of_columns>], <integer_type> <size_of_rows>, <integer_type> <size_of_rows>);
	return_type/void <function_name>( <type> *(<name>)[<maximum_size_of_columns>], <integer_type> <size_of_rows>, <integer_type> <size_of_rows>);

Пример:
```c++
int sumAllElementsInMatrix(int mrx[][10], int rowSize, int columnSize);
int sumAllElementsInMatrix(int *(mrx)[10], int rowSize, int columnSize);
```
Извикването става, само с името на масива:
```c++
// somewhere in main()

	int my_mrx[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	...
	cout << sumAllElementsInMatrix(my_mrx, 3, 3);
```

### NB! Не можем да връщаме масив от функция. Но можем да върнем указател. Виж следващата точка.

### Функции(advanced level)
#### Параметри vs. Аргументи
**Параметър** на функция (понякога наричан **формален параметър**) е променлива, използвана при декларацията/дефиницията на функцията.
```c++
void foo(int x); // декларация (прототип на функцията) -x е параметър
 
void foo(int x) // дефиниция  -x е параметър
{
}
```
**Аргумент** (понякога наричан **действителен параметър**) е стойността, която се подава на функцията при извикването й.
```c++
foo(6); // 6 е аргумент предаден на параметъра x
```
Когато някъде се извика функцията foo() се с аргумента 6, параметърът х на foo се създава и инициализира със стойността на аргумента(т.е. със 6). Параметрите имат локална видимост и затова, когато функцията завърши изпълнението си те се разрушават.
```c++
void foo(int x) // х се създава тук
{
} // х се унищожава тук
```

#### Подаване на аргументи към финкции по стойност, адрес и референция
Когато използваме функции(както го правим до сега) и подаваме даден аргумент (подаване по стойност), ние дефакто създаваме нова променлива някъде в паметта (виж графиката) и всички промени които осъществим се правят над новата променлива, но не и над променливата която сме подали.

За да правим промени над оригиналните променливи, които сме подали, се използват указателите и псевдонимите. 

Казано разговорно какво представляват:
	- Псевдонимът казва, когато подадеш дадена променлива, на тази която се присвоява, направо я взима по референция, т.е направо я вземи където се намира по адреса, който е и оперира в оригиналната памет.
	- Указател - подаваме адреса на променливата и оперираме над него

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week10/diagrams/PRF.png)

Пример: Искаме да намерим сумата на две числа, като използваме трета променлива в която да се пази резултата. (т.е за учебна цел няма да връщам сумата като резултат, а ще пазя резултата в предварително създадена променлива)

```c++
// Example program
#include <iostream>

// without reference or pointer => will lose value of sum
void sumWithoutRefOrPointer(int numL, int numR, int sum)
{
    sum = numL + numR;
}

// with reference
void sumIt(int numL, int numR, int &sum)
{
    sum = numL + numR;
}

// with pointer
void sumIt(int numL, int numR, int *sum)
{
    *sum = numL + numR;
}

int main()
{
  int numL = 4, numR = 6, sum = 0;
  
  sumWithoutRefOrPointer(numL, numR, sum);
  std::cout << "1) " << sum << std::endl; // 0
  
  sumIt(numL, numR, sum);
  std::cout << "2) " << sum << std::endl; // 10
  
  sumIt(numL + 1, numR, &sum); // we must put adress of sum
  std::cout << "3) " << sum << std::endl; // 11

  return 0;

}
```

Виждаме това което коментираме до сега. Там къде сме подали по стойност (т.е. първата функция), правим копие и след края на изпълнение се трие това копие, като стойността на sum (това е main) не е променена.
Когато подаваме по референция ние работим директно в паметта и от там идва и промяната на стойността на променливата sum.
При използването на указател наблюдаваме същото, вземи адреса на променливата и след това с * казваме влез вътре и промени стойността.

## Позлезно да прочетете:
[Подаване по стойност](http://www.learncpp.com/cpp-tutorial/72-passing-arguments-by-value/)

[Подаване по референция](http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/)

[Подаване по адрес](http://www.learncpp.com/cpp-tutorial/74-passing-arguments-by-address/)
