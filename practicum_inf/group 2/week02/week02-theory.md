# Практикум #2

## Какво ще научим днес?
* Булеви изрази
* Блок {}, видимост на данни
* if конструкции
* Конструкция ?:
* switch конструкция
* std namespace

## Булеви изрази (Boolean expressions)
### Едно условие
Както видяхме в предното упражнение, когато искаме да проверим **дали дадено нещо е истина или не**, използваме типа **bool** в различни булеви изрази. Видяхме също, че операторите за сравнение връщат булева(логическа) стойност, но с тях може да се сравнява **само едно условие**. Например, ако искаме да проверим дали две числа са равни, можем директно да изведем резултата от сравнението.
```c++     
     int x = 5;
     int y = 3;
     cout << x == y; // 0
     cout << x >= y; // 1
     cout << x != y; // 1
```
### Няколко условия
А какво се случва, когато искаме да са изпълнени **няколко условия** наведнъж? Например, ако искаме да проверим дали две неща съвпадат, то трябва да сравним възможно най-много техни характеристики. Например, ако искам да проверим дали печелим от лотарията, то трябва да проверим дали всички 6 числа от тегленето съвпадат с числата от нашия лотариен билет. Освен това, може да ни се наложи поне едно условие от няколко възможни е изпълнено. Например, ако закъсняваме за практикума по УП, то или сме изпуснали автобуса, или се мотаем пред ФМИ, или си пускаме билета за 6/49. В тези случаи, **комбиниранраме различни булеви изрази в по-голям израз**, като се интересуваме от неговия резултат. За да комбинираме използваме конюнкция(логическо-И) и дизюнкция(логическо-ИЛИ). Don't worry! Ще ги упражнявате в часовете по дискретни структури. Опитайте се да познаете резултата от следните изрази:
```c++
   int x = 5;
   int y = 4;
   int z = x;
   
   cout << (x == z) && (y < x) && (y != z);
   cout << !(z == y) || (x != y) || (x <= z);
```
Можем да комбинираме като използваме различни логически оператори. Опитайте се да отгатнете отговора:
```
   (true && true) || false                                                    
   (false && true) || true
   (false && true) || false || true 
   (5 > 6 || 4 > 3) && (7 > 8)
   !(7 > 6 || 3 > 4)
```
Но смесването им, не е произволно. Тези оператори имат **приоритет**, както събирането и умножението в математиката. **Логическото-И има по-висок приоритет от логическото-ИЛИ**, така че логическите-И оператори ще бъдат оценявани преди логическите-ИЛИ оператори. Например изрази като **value1 || value2 && value3** се оценява като **value1 || (value2 && value3)**, a не като **(value1 || value2) && value3**. 
### NB!
#### При смесване на логически-И и логически-ИЛИ оператори в един и същ израз е добра практика изрично да се посочат операндите на всеки оператор. Това помага да се предотвратят грешките с приотитета, прави кода ви по-лесен за четене и ясно дефинира как сте възнамерявали да оценявате израза. Например, вместо да напишете value1 && value2 || value3 && value4, по-добре напишете (value1 && value2) || (value3 && value4).

#### Закони на Де Морган - логическо-НЕ
Много програмисти правят грешката да мислят, че **!(X && Y) е същото нещо като !X && !Y**. За съжаление обаче, не можете да "използвате" логическото-НЕ по този начин.

Законите на **Де Морган** ни казват как трябва да се преобразуват логическите изрази в тези случаи:

    !(X && Y) е еквивалентно на !X || !Y
    !(X || Y) е еквивалентно на !X && !Y

**С други думи, когато използвате логическo-НЕ, трябва да обърнете логическoто-И към логическо-ИЛИ, и обратно!**

## Блок {} (Block), видимост на данни (Scope)
Блок в програма ще наричаме парчета код които са заградени с { <код> }. Конвенцията за писане изисква новите редове след отварящата скоба - { да започват навътре от предходния ред (в общия случай с една табулация място).  
```c++
{
	std::cout << "One tab inside" << std::endl;
}
```

**Видимост на променливите**, наричаме частта от програмата където можем да **достъпим** дадените променливи. Видимостта, спрямо това как я разглеждаме, можем да я разделим в 3 категории:
 - Вътре във функция или блок, се нарича локална променлива
 - В дефиниция на функция - нарича се формален параметър (ще го разгледаме подробно скоро) 
 - Вън от всички функции, тогава се нарича глобална променлива

**Локалните променливи са видими само в конкретния блок в който са декларирани и във всеки негов подблок.**
**Глобалните променливи са дефинирани извън всички функции, обикновено най - отгоре в програмата. Те могат да бъдат достъпени от всички блокове в програмата.**

Шега: Какъв е най-добрият префикс за именуване на глобална променлива?

Отговор: //

Извод: **Избягвайте използването на глобални променливи, ако е възможно! Ако трябва да ги използвате, ги използвайте разумно и предпазливо.** 

```c++
#include<iostream>

// Глобални променливи
bool check;

int main()
{
	// Локални променливи
	int age = 19, fn = 56789;

	std::cout << age;

	{
		std::cout << " " << fn;
	}
	
	check = true;
	return 0;
}
```

## if конструкции (if-statement)
Контролирането потока на програмата, взимането на решение **кога дадени фрагменти да се изпълнят и кога не**, е важно умение за всеки програмист. За това умение се използват различни инструменти. Един такъв инструмент е **условният оператор**, той проверява **дали дадено условие е изпълнено и спрямо този резултат изпълнява зададено следствие** от програмистта. Условният оператор има две основни конструкции(форми): **кратка и пълна.**

### Кратка форма на if
Синтаксис:
```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява блокът от операции, ако върнатият резултат е false блокът се пропуска, т.е. няма да се изпълни нищо. 

```c++
#include <iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE) 
		std::cout << "Drink denied" << std::endl;

	return 0;
}
```
Блок-схема:

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week02/diagrams/Diagram_if.png)

### Пълна форма на if
Синтаксис:
```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
else
{
	// ...
	// блок от операции, които ще бъдат изпълнени 
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява първият блок от операции, ако върнатият резултат е false - вторият блок. 

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE)
	{ 
		std::cout << "Drink denied" << std::endl;
	}	
	else
	{
		std::cout << "Drink permitted" << std::endl;
	} 

	return 0;
}
```
Блок-схема:

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week02/diagrams/Diagram_if_else.png)

#### Вложена форма(Nested form)
```c++
#include<iostream>

int main()
{
	int number = 15;
	
	if (number % 3 == 0)
	{
		if (!(number % 5))
			std::cout << "Divided by 3 and 5" << std::endl;
		else
			std::cout << "Divided by 3 but not by 5" << std::endl;
	}
	
	return 0;
}
```
### Други форми - if-else-if
Синтаксис и семантика:
```c++
if ( <булев_израз> ) 
{
	// ...
  	// Ако <булев_израз> е оценен с true, ще се изпълни този блок с операции
  	// ...
}
else if ( <друг_булев_израз> ) 
{
  	// ...
  	// Ако <друг_булев_израз> е оценен с true И <булев_израз> е оценен с false, 
  	// тогава ще се изпълни този блок с операции
  	// ...
}
else // тази клауза не е задължителна
{
  	// ...
  	// ще се изпълни този блок, ако <булев_израз> И <друг_булев_израз> са оценени с false
  	// ...
}
```

```c++
#include<iostream>

int main()
{
	int a = 19;
	if (a % 2 == 0)
	{
	    std::cout << "divided by 2" << std::endl;
	}
	else if (a % 3 == 0)
	{
		std::cout << "divided by 3" << std::endl;
	}
	else
	{
	      std::cout << "Not divided by 2 and 3" << std::endl;
	}

	return 0;
}
```
## Конструкция ?: (Ternary operator)
?: е форма която наподобява конструкцията if - else. Формално ще наричаме оператора ?: **тернарен оператор**.

Синтаксис: 
```c++
<булев_израз> ? <оператор_при_истина> : <оператор_при_лъжа>
```
Семантика: 
Изчислява се булевият израз, след което се изпълнява при:
 - върнат резултат истина (true) - изпълнява се операторът след ?
 - върнат резултат лъжа (false) - изпълнява се операторът след :

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 19;

	std::cout << (age < ALLOW_AGE ? "Drink denied" : "Drink permitted") << std::endl;
	
	return 0; 
}
```

## Оператор switch(Switch statement)
Операторът **switch** позволява тестването на дадена променлива за равенство измежду списък от стойностти. Всяка стойност за проверка се нарича **случай (case).**

Синтаксис:
```c++
switch(<израз|стойност>)
{
	case <стойност_за_проверка>: <операции_за_изпълнение>; break; // break; не е задължително 
	...
	case <стойност_за_проверка>: <операции_за_изпълнение>; break;
	
	default: <операции_за_изпълнение>; break;
}
```
Семантика: Подаваме дадена стойност като параметът на switch, след което се проверява в кой случай стойността от този параметър ще съвпадне по стойност с някоя стойност за проверка, при което се изпълнява операциите подадени към този случай. Ако никоя стойност не съвпадне с подадената се изпълнява случаят default.

### Допълнителни правила:
 * може да имате **неограничен брой случаи (case)**, като трябва за всеки един да дадете стойност по която да се проверява;
 * стойносттите, по които проверяваме, трябва да бъдат **от същия тип** както подадената за проверка; 
 * при откриване на съвпадение **се изпълняват подадените операции до срещане на оператор break**, т.е ако е влезнал във втория case и няма break в него, ще се изпълнят всички оператори в останалите case-ове до достигане на оператор break;
 * при стигане до break, изпълнението на оператора switch се **прекратява и продължава изпълнението на програмата** след него;
 * default е **опционален**, т.е не е от задължителния синтаксис на оператора switch. Той се използва когато никой от изброените условия не се е изпълнило и искаме да отбележим това;

Блок-схема:

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week02/diagrams/Diagram_switch.png)

```c++
#include <iostream>
 
int main () {
   // local variable declaration:
   char grade = 'D';

   switch(grade) {
      case 'A' :
         std::cout << "Excellent!" << std::endl; 
         break;
      case 'B' :
      case 'C' :
         std::cout << "Well done" << std::endl;
         break;
      case 'D' :
         std::cout << "You passed" << std::endl;
         break;
      case 'F' :
         std::cout << "Better try again" << std::endl;
         break;
      default :
         std::cout << "Invalid grade" << std::endl;
   }
   std::cout << "Your grade is: " << grade << std::endl;
 
   return 0;
}
```
## Std namespace

Да приемем, че отивате на парти в апартамента на приятел. Там е пълно с хора. Вашият приятел ви запознава с гостите: Пешо, Иван, Георги, Александра, Анди, Мария, Александра и тн. Малко по-късно, когато вече всички са на градус решавате, че ще играете игра по двойки и се опитвате да се разделите, като всеки тегли картонче с името на съотборника си. Когато идва вашия ред да изтеглите са останали само две картончета и за съжаление и на двете пише Александра. Но вие искате да сте в отбор с по-красивата Алекс. Кое картонче за кое момиче е? Ако не е имало някаква допълнителна информация, която да ви помогне да решите кое картонче за кое момиче е (например да си спомните, че красивата Алекс винаги слага звезда до името си, когато го изписва), ще трябва да се обърнете към своя приятел и да поискате повече информация. Но това би било неуместно, защото не толкова хубава Алекс веднага би се разсърдила. А колко по-лесен щеше да и ибора, ако едната беше написала Алекс, а другата Александра.. :D

По същия начин **C++ изисква всички идентификатори (имена на променливи и/или функции) да не са двусмислени.** Ако два идентификатора са въведени в една и съща програма по начин, който компилаторът не може да ги разграничи, съставителят или линкерът ще доведе до грешка. Тази грешка обикновено се нарича "конфликт с именуването". Тъй като програмите се увеличават и използват повече идентификатори, шансовете за конфликт между имената се увеличават значително. 

Когато C ++ бил първоначално проектиран, всички идентификатори в стандартната библиотека C++ (като cin и cout) били на разположение за директно използване. Това обаче означава, че всеки идентификатор в стандартната библиотека може потенциално да е в конфликт с името, което сте избрали за вашите собствени идентификатори. Така че, разработчиците C++ преместили цялата функционалност на стандартната библиотека в специална област, наречена **пространство с имена** или **namespace**.

Подобно на град, който гарантира, че всички пътища в града имат уникални имена, **пространството с имена гарантира, че идентификаторите в пространството на имената са уникални.** Това предотвратява конфликтите на идентификаторите в пространство от имена с други идентификатори.

### using namespace std;

Оказва се, че името на оператора за изход **std::cout**, което използваме в повечето си примери, не е наистина "std::cout". Това всъщност е просто **"cout"**, а **"std"** е името на пространството с имена, в което името живее. **Цялата функционалност в стандартната библиотека C++ се дефинира в пространство с имена std (кратко за standard)**. По този начин не е нужно да се притесняваме за функционалността на стандартната библиотека, която има конфликт на именуване с нашите собствени идентификатори.

За да избегнем постоянното пояснение към компилатора, използваме ключовия ред using namespace std; веднага след добавянето на необходимите ни библиотеки.
```c++	
	#include <iostream>
	#include <other_library>
	
	using namespace std;
```
Taка вече няма да е необходимо в програмата ни пред всеки оператор за вход или изход да слагаме **std::**.
